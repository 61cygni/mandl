# --
# File: mesh_explore.py
#
# Viewer to explore results generated by fractal.py.
# Command-line (and --demo) parameters set how the image is generated.
#
# This means that when fractal.py runs out of frames, it might be
# able to render, that there will be an error in this exploration.
# If you run out of frames, then adjust the value in fractal.py for
# 'duration'.  This might happen after adjusting 'fps' as well,  except 
# that changing 'fps' will ALSO change the frame number that a 
# feature appears at.  
#
# In addition, to achieve higher depths, you need to adjust 2 values
# as you explore:
# 1.) max_iter (e.g. line ~1550 in fractal.py sets for --demo)
# 2.) FLINT_HIGH_PRECISION_SIZE (e.g. line ~31 in fractalmath.py)
#
# If the image goes all white, it's likely you need higher iteration count.
# If the image goes splotchy, it's likely you need higher precision.
# If the image goes pixellated, then you definitely need higher precision.
#
# --

import getopt
import os
import pickle

import subprocess

from divemesh import *
from fractal import *
from fractalmath import *

import matplotlib as mpl
from matplotlib import pyplot as plt

def parse_options():
    params = {}

    argv = sys.argv[1:]
    opts, args = getopt.getopt(argv, "f:c:",
                               ["frame=",
                                "center=",
                                ])

    for opt, arg in opts:
        if opt in ['f', '--frame']:
            params['frameNumber'] = int(arg)
        elif opt in ['-c', '--center']:
            params['centerString'] = arg

    # Eventually, we should just be able to point to a project file
    # (as a pickle), and this ui script will read that, and not have
    # to create all its own commands, paths, and parameters, though
    # we should probably build our own 'exploration' cache separately.
    #
    #### Custom flint, just mandelbrot
    params['fractalCommandBase'] = 'python3.9 ./fractal.py --algo=mandelbrot_solo --demo --burn --flintcustom --clip-frame-count=1'
    params['wholeCacheFolder'] = "demo1_cache/image_frames/flint/mandelbrot_solo"
    #
    #### Standard Flint, just mandelbrot
    #params['fractalCommandBase'] = 'python3.9 ./fractal.py --algo=mandelbrot_solo --demo --burn --flint --clip-frame-count=1'
    #params['wholeCacheFolder'] = "demo1_cache/image_frames/flint/mandelbrot_solo"
    #
    #### Custom Flint, smooth
    #params['fractalCommandBase'] = 'python3.9 ./fractal.py --algo=smooth --demo --burn --flintcustom --clip-frame-count=1'
    #params['wholeCacheFolder'] = "demo1_cache/image_frames/flint/smooth"
    #
    #### Native calc, smooth
    # NOTE: When using 'native', complex should be formatted with
    # parens like "(0.1+0.04j)"
    #params['fractalCommandBase'] = 'python3.9 ./fractal.py --algo=smooth --demo --burn --clip-frame-count=1'
    #params['wholeCacheFolder'] = "demo1_cache/image_frames/native/smooth"
    #
    #### Native calc, just mandelbrot
    #params['fractalCommandBase'] = 'python3.9 ./fractal.py --algo=mandelbrot_solo --demo --burn --clip-frame-count=1'
    #params['wholeCacheFolder'] = "demo1_cache/image_frames/native/mandelbrot_solo"

    params['frameIncrement'] = 1
    return params

def nextClicked(event):
    global params
    origFrameNumber = params.get('frameNumber', 0)
    frameNumber = origFrameNumber + params.get('frameIncrement', 1)
    params['frameNumber'] = frameNumber

    updateForFrameNumber(frameNumber)

def prevClicked(event):
    global params
    origFrameNumber = params.get('frameNumber', 0)
    frameNumber = origFrameNumber - params.get('frameIncrement', 1)
    if frameNumber < 0:
        frameNumber = 0
    params['frameNumber'] = frameNumber

    updateForFrameNumber(frameNumber)

def updateForFrameNumber(frameNumber):
    global uiElements
    clickedLocus = uiElements.get('lastClickedLocus', None)
    if clickedLocus == None:
        return

    runFractalCall(frameNumber, str(clickedLocus))

    imageFileTitle = "%d.tiff" % frameNumber
    imageFileName = os.path.join(params['wholeCacheFolder'], imageFileTitle)
    imageData = mpl.image.imread(imageFileName)

    clickableImage = uiElements['clickableImage']
    clickableImage.set_data(imageData)

    meshFileTitle = "%s.mesh.pik" % imageFileTitle
    meshFileName = os.path.join(params['wholeCacheFolder'], meshFileTitle)
    with open(meshFileName, 'rb') as meshHandle:
        diveMesh = pickle.load(meshHandle)

    uiElements['diveMesh'] = diveMesh

    updateTitle()
    plt.draw()

def runFractalCall(frameNumber, centerString):
    global params
    fractalCallString = "%s --clip-start-frame=%d" % (params['fractalCommandBase'], frameNumber)
    if centerString != None:
        fractalCallString += " --center='%s'" % (centerString)

    print("Calling: %s" % fractalCallString)
    subprocess.call([fractalCallString], shell=True)
    print("(Call finished.)")
    print("Exploration invocation for this point:")
    print("python3.9 ./mesh_explore.py --frame=%d --center='%s'" % (frameNumber, centerString))
    print("")

def plusClicked(event):
    global params
    origFrameIncrement = params.get('frameIncrement', 1)
    frameIncrement = origFrameIncrement + 1
    params['frameIncrement'] = int(frameIncrement)

    updateAdvanceText() 
    plt.draw()

def minusClicked(event):
    global params
    origFrameIncrement = params.get('frameIncrement', 1)
    frameIncrement = origFrameIncrement
    if frameIncrement != 1:
        frameIncrement -= 1
    params['frameIncrement'] = int(frameIncrement)

    updateAdvanceText() 
    plt.draw()

def updateAdvanceText():
    global uiElements
    advanceText = uiElements['advanceText']
    
    global params
    frameIncrement = params.get('frameIncrement', 1)
    if frameIncrement == 1:
        newText = "+ 1 frame"
    else:
        newText = "+ %d frames" % frameIncrement

    advanceText.set_text(newText)
 
def updateTitle():
    global uiElements
    diveMesh = uiElements['diveMesh']

    widthString = diveMesh.mathSupport.shorterStringFromFloat(diveMesh.imagMeshGenerator.baseWidth, 10)
    plt.suptitle("%s wide" % widthString)

def onclick(event):
    global uiElements

    # event.xdata and event.ydata are floats, but we want pixel ints
    #print(event)
    if event.xdata is None or event.ydata is None:
        return

    # Only clicks in the image can change the focus.
    clickableImage = uiElements['clickableImage']
    if event.inaxes != clickableImage.axes:
        return

    clickX = int(event.xdata)
    clickY = int(event.ydata)

    diveMesh = uiElements['diveMesh']
    meshData = diveMesh.generateMesh()
    #print("click (%s,%s)" % (str(clickX), str(clickY)))
    clickedLocus = meshData[clickY, clickX]
    # Extra steps to try to clear out the 'error' radius from arb.
    clickedRealString = diveMesh.mathSupport.stringFromFloat(clickedLocus.real)
    clickedImagString = diveMesh.mathSupport.stringFromFloat(clickedLocus.imag)
    rebuiltClickedLocus = diveMesh.mathSupport.createComplex(clickedRealString, clickedImagString)
    print(rebuiltClickedLocus)
    uiElements['lastClickedLocus'] = rebuiltClickedLocus

if __name__ == '__main__':

    global params
    params = parse_options()
    frameNumber = params.get('frameNumber', 0)

    centerString = params.get('centerString', None)
    
    # Run the whole frame on first call, so we can read the
    # mesh dimensions from the result.  Otherwise, we have to
    # guess at a lot of things like image size.
    runFractalCall(frameNumber, centerString)

    global uiElements
    uiElements = {}

    # Start off with the parameterized locus as the center.
    uiElements['lastClickedLocus'] = centerString

    imageFileTitle = "%d.tiff" % frameNumber
    meshFileTitle = "%s.mesh.pik" % imageFileTitle
    meshFileName = os.path.join(params['wholeCacheFolder'], meshFileTitle)

    with open(meshFileName, 'rb') as meshHandle:
        diveMesh = pickle.load(meshHandle)

    uiElements['diveMesh'] = diveMesh
    
    mainFigure = plt.figure()
    uiElements['mainFigure'] = mainFigure

    imageFileName = os.path.join(params['wholeCacheFolder'], imageFileTitle)
    imageData = mpl.image.imread(imageFileName)
    uiElements['clickableImage'] = plt.imshow(imageData)

    mainFigure.canvas.mpl_connect('button_press_event', onclick)

    buttonWidth = 0.1
    buttonHeight = 0.06

    gutter = 0.01
    positionX = gutter
    positionY = gutter

    button1Axes = plt.axes([positionX,positionY,buttonWidth,buttonHeight])
    prevButton = mpl.widgets.Button(button1Axes, label="Prev")
    prevButton.on_clicked(prevClicked)
    uiElements['previousButton'] = prevButton
   
    positionX += buttonWidth + gutter

    button2Axes = plt.axes([positionX,positionY,buttonWidth,buttonHeight])
    nextButton = mpl.widgets.Button(button2Axes, label="Next")
    nextButton.on_clicked(nextClicked)
    uiElements['nextButton'] = nextButton

    positionX += buttonWidth + gutter

    smallerButtonWidth = .04

    button3Axes = plt.axes([positionX,positionY,smallerButtonWidth,buttonHeight])
    plusButton = mpl.widgets.Button(button3Axes, label="+")
    plusButton.on_clicked(plusClicked)
    uiElements['plusButton'] = plusButton

    positionX += smallerButtonWidth + gutter

    button4Axes = plt.axes([positionX,positionY,smallerButtonWidth,buttonHeight])
    minusButton = mpl.widgets.Button(button4Axes, label="-")
    minusButton.on_clicked(minusClicked)
    uiElements['minusButton'] = minusButton

    positionX += 0.8 # BUG: Not sure why adding another button width is wrong here
    #positionX += smallerButtonWidth + gutter

    advanceText = plt.text(positionX, positionY, "+ frame", horizontalalignment='left')
    uiElements['advanceText'] = advanceText
    updateAdvanceText()

    updateTitle()

    plt.show()

