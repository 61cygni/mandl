# Time Tinker Demo

Everything except the intro title card and fade-ins was generated by the parameter keyframes in a timeline, at a native framerate of 23.976, ending at a window width around e-54.  Since I don't have the intro title stuff working yet on the branch, I assembled this in Premiere (slapped the audio track and title card onto it, after planning for everything to start a few seconds later).

The demo isn't very high resolution, but that's just to save render time.  It also isn't the most interesting point, but that's just a result of not having explored a whole lot before committing to a plan.
(Note, the window widths all should be modified if the aspect ratio changes from 4:3).

When constructing an animation, it really helps to keep the frameWidth and frameHeight (the json file's values should be what controls actual output) as small as is tolerable, so you can quickly see if you're on track with what you're trying to make happen.  Same with FPS, where I usually work at 1/4 or 1/8 of full speed.


# How This Was Made 

## Project Creation

A project is just a subfolder, which comes with an initial set of files and folders for organization.

Created a 'project', which is a set of subdirs and a params file.

python3.9 ./fractal.py --make-project="time_tinker" --math-support="flintcustom"

Edited the time_tinker/params.json file to lower the exploration resoultion.


## Exploration

Since this is a kind of work-out demo, I planned out a series of zooms, pans, and modifications to try to show off various mechanisms. 

Listening and measuring out the music track gave me specific (millisecond) time targets to try to hit with the parameter keyframes.  Then, points of interest were saved as mesh markers, according the drawn up plan.  

Mesh markers are saved by clicking the 'save' button while exploring.  

For this demo, I started with a set of about 10 markers.  To get more simply connected zoom phases, I actually started at the furthest dive point (the point with the smallest window width), and generally proceeded backwards through the exploration.

python3.9 ./mesh_explore.py --project='time_tinker' --real-width=2.0 --imag-width=1.5

NOTE: As exploring, the current window leaves behind a command invocation that can start the exploration script at the same place again.  This is helpful when working in phases, and also when trying to tinker with specific parameters.


## Timeline Creation

Next, the markers were used to auto-generate a rough timeline as a basis to build something more complex from.  All the times except for the endpoints will be moved around, but assigning them like this is a reasonable start. 

python3.9 ./markers_to_timeline.py --project="time_tinker" --marker-list=[9,8,7,6,5,4,3,2,1] --timeline-name='time_tinker_sequence_01' --duration=75.0

Then, I just went to town modifying and keyframes in the json by hand.  I figured out a whole list of time offsets that I wanted to use, and made the keyframes from the zoom plan from above hit at those time offsets.

I'd prefer have a 'load from script function' mechanism be the default for loading timelines (and already figured out how that will work), but this was the fastest way I could get to a demo.

cp time_tinker/edit/timelines/time_tinker_sequence_01 time_tinker/edit/timelines/time_tinker_demo

To keep sane, I kept illegal comment lines in the json file as I worked, then ran the whole thing through a comment-removal script at the end.  The comments are still in 'time_tinker_demo'.

python3.9 ./strip_comments.py time_tinker/edit/timelines/time_tinker_demo > time_tinker/edit/timelines/time_tinker_demo_clean

Note(s): Interpolations are very sensitive, and easy to get wrong enough that your planned animation will suffer.  

One of the most important tricks seems to be to take the most-zoomed-in center definitions, and just copy/paste those centers on top of earlier marker center points, if the dive stays centered on that point.  This makes it so there's no accidental drifting around of the focus point as the dive progresses.


## Rendering Setup

The most direct way to create rendered frames is to run a timeline all at once, but there's some other improvements below if this isn't quite enough.

When rendering for output, don't forget to up the frameWidth, frameHeight, and fps in the timeline file.

python3.9 ./fractal.py --project='time_tinker' --timeline-name='time_tinker_demo_clean'

This command does generate an output video file, but the individual frame .tiff files are still probably the most useful thing for using in a video project or setup.


### Batching

Helper batching script can split up all the frame numbers in a timeline into files.  Default is to round-robin frame numbers, so the overall animation can be viewed from start towards finish as it renders.

python3.9 ./batch_files_for_timeline.py --project='time_tinker' --timeline-name="time_tinker_demo_clean" --batch-count=10

Then, each of the batch scripts needs ot be run through fractal.py to generate .tiff frames.

(These were thrown in a one-off shell script, but we'll have something more friendly soon.)

python3.9 ./fractal.py --project='time_tinker' --timeline-name="time_tinker_demo_clean" --batch-frame-file='time_tinker/edit/timelines/time_tinker_demo_clean_batches/batch_0.txt' &
python3.9 ./fractal.py --project='time_tinker' --timeline-name="time_tinker_demo_clean" --batch-frame-file='time_tinker/edit/timelines/time_tinker_demo_clean_batches/batch_1.txt' &
python3.9 ./fractal.py --project='time_tinker' --timeline-name="time_tinker_demo_clean" --batch-frame-file='time_tinker/edit/timelines/time_tinker_demo_clean_batches/batch_2.txt' &
python3.9 ./fractal.py --project='time_tinker' --timeline-name="time_tinker_demo_clean" --batch-frame-file='time_tinker/edit/timelines/time_tinker_demo_clean_batches/batch_3.txt' &
python3.9 ./fractal.py --project='time_tinker' --timeline-name="time_tinker_demo_clean" --batch-frame-file='time_tinker/edit/timelines/time_tinker_demo_clean_batches/batch_4.txt' &
python3.9 ./fractal.py --project='time_tinker' --timeline-name="time_tinker_demo_clean" --batch-frame-file='time_tinker/edit/timelines/time_tinker_demo_clean_batches/batch_5.txt' &
python3.9 ./fractal.py --project='time_tinker' --timeline-name="time_tinker_demo_clean" --batch-frame-file='time_tinker/edit/timelines/time_tinker_demo_clean_batches/batch_6.txt' &
python3.9 ./fractal.py --project='time_tinker' --timeline-name="time_tinker_demo_clean" --batch-frame-file='time_tinker/edit/timelines/time_tinker_demo_clean_batches/batch_7.txt' &
python3.9 ./fractal.py --project='time_tinker' --timeline-name="time_tinker_demo_clean" --batch-frame-file='time_tinker/edit/timelines/time_tinker_demo_clean_batches/batch_8.txt' &
python3.9 ./fractal.py --project='time_tinker' --timeline-name="time_tinker_demo_clean" --batch-frame-file='time_tinker/edit/timelines/time_tinker_demo_clean_batches/batch_9.txt' &

Finally, all the tiff files *can be* thrown into a single animation file, for easier viewing.  Most likely though, using the output folder as .tiff sequence is the best way to use or import the individual frames.

python3.9 compile_video.py --dir='time_tinker/output/time_tinker_demo_clean/' --out='time_tinker.mp4' --frame-count=1798


